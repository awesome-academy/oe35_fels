<?php

namespace Tests\Feature\Http\Controllers\Admin;

use App\Http\Controllers\Admin\CourseController;
use App\Http\Requests\CourseRequest;
use App\Models\Course;
use App\Models\Role;
use App\Models\User;
use App\Repositories\ModelsInterface\CourseRepositoryInterface;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Foundation\Testing\WithoutMiddleware;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Validator;
use Mockery;
use Tests\TestCase;
use Illuminate\Http\Request;
use Illuminate\Support\Collection;

class CourseControllerTest extends TestCase
{
    use WithoutMiddleware;

    protected $courseRepoMock;
    protected $courseController;
    protected $jsonMock;
    protected $course;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->courseRepoMock = Mockery::mock(CourseRepositoryInterface::class)->makePartial();
        $this->courseController = new CourseController($this->courseRepoMock);
        $this->jsonMock = Mockery::mock(JsonResponse::class)->makePartial();
        $this->course = factory(Course::class)->create();
    }

    public function test_index_return_json_data()
    {
        $url = route('admin.courses.index');
        $response = $this->get($url, [
            'HTTP_X-Requested-With' => 'XMLHttpRequest'
        ]);

        $this->courseRepoMock->shouldReceive('jsonCourses')->once()->andReturn($this->jsonMock);
        $data = $this->courseRepoMock->jsonCourses();

        $this->assertInstanceOf(JsonResponse::class, $data);
        $response->assertStatus(200);
        $response->assertJsonStructure([
            'data' => [
                0 => [
                    'DT_RowIndex',
                    'id',
                    'name',
                    'description',
                    'created_at',
                    'updated_at'
                    ]
                ],
            'recordsFiltered',
            'recordsTotal',
        ]);
    }

    public function test_index_return_view()
    {
        $request = new Request();
        $view = $this->courseController->index($request);

        $this->assertEquals('back-end.courses.index', $view->getName());
    }

    public function test_course_request_expected_validation_rules()
    {
        $request = new CourseRequest();

        $this->assertEquals([
            'name' => [
                'required',
                'min:2',
                'max:255',
            ],
        ], $request->rules());
    }

    public function test_it_should_fail_validation_without_name()
    {
        $request = new CourseRequest();

        $validator = Validator::make([
            'description' => 'this is a test',
        ], $request->rules());

        $this->assertFalse($validator->passes());
        $this->assertContains('name', $validator->errors()->keys());
    }

    public function test_valid_data()
    {
        $request = new CourseRequest();
        $data = $this->provide_invalid_data();
        $validator = Validator::make($data, $request->rules());

        $this->assertFalse($validator->passes());
    }

    public function provide_invalid_data()
    {
        return [
            [
                'name' => '1',
                'description' => 'this is a test',
            ],
            [
                'name' => '',
                'description' => null,
            ],
            // ...
        ];
    }

    public function test_it_should_create_a_course_successfully()
    {
        $role = factory(Role::class)->create();
        $user = factory(User::class)->create([
            'role_id' => $role->id,
        ]);

        $response = $this->actingAs($user)
            ->json('POST', '/admin/courses', [
                'name' => 'test',
                'description' => 'this is a test',
            ]);

        $response->assertStatus(201);
        $this->assertDatabaseHas('courses', [
            'name' => 'test',
            'description' => 'this is a test'
        ]);
    }

    public function test_it_should_failed_when_creat_a_course_without_name()
    {
        $role = factory(Role::class)->create();
        $user = factory(User::class)->create([
            'role_id' => $role->id,
        ]);

        $response = $this->actingAs($user)
            ->json('POST', '/admin/courses', [
                'description' => 'this is a test',
            ]);

        $data = [
            'message' => 'The given data was invalid.',
            'errors' => [
                'name' => ['Name is required!'],
                ]
            ];

        $response->assertStatus(422);
        $response->assertJson($data);
    }

    public function test_store_request_create()
    {
        $request = new CourseRequest([
            'name' => 'hello',
            'description' => 'Testing update',
        ]);

        $this->courseRepoMock->shouldReceive('storeCourseJSON')->with($request->all())->andReturn(true);
        $data = $this->courseRepoMock->storeCourseJSON($request->all());

        $this->assertTrue($data);
        $response = $this->courseController->store($request);

        $this->assertEquals(201, $response->getStatusCode());
    }

    public function test_store_request_update()
    {
        $request = new CourseRequest([
            'record_id' => $this->course->id,
            'name' => 'hello',
            'description' => 'Testing update',
        ]);

        $this->courseRepoMock->shouldReceive('storeCourseJSON')->with($request->all())->andReturn(true);
        $data = $this->courseRepoMock->storeCourseJSON($request->all());

        $this->assertTrue($data);
        $response = $this->courseController->store($request);

        $this->assertEquals(201, $response->getStatusCode());
    }

    public function test_course_edit()
    {
        $course = $this->course;
        $this->courseRepoMock->shouldReceive('findById')->with($course->id)
            ->andReturn(Course::class);
        $this->courseRepoMock->findById($course->id);
        $response = $this->courseController->edit($course->id);

        $this->assertEquals(200, $response->getStatusCode());
    }

    public function test_destroy_course_successfully()
    {
        $courseId = $this->course->id;
        $this->courseRepoMock->shouldReceive('findById')->with($courseId)
            ->andReturn(Course::class);
        $this->courseRepoMock->findById($courseId);
        $this->courseRepoMock->shouldReceive('destroy')
            ->andReturn(true);
        $this->courseRepoMock->destroy($this->course);
        $response = $this->courseController->destroy($courseId);
        $data = $response->getOriginalContent();

        $this->assertEquals(200, $response->getStatusCode());
        $this->assertEquals(false, $data['errors']);
    }

    public function test_destroy_course_fail()
    {
        $response = $this->courseController->destroy(0);
        $data = $response->getOriginalContent();

        $this->assertEquals(500, $response->getStatusCode());
        $this->assertEquals(false, $data['success']);
    }

    public function test_get_course_list()
    {
        $this->courseRepoMock->shouldReceive('getCourseList')->andReturn(Collection::class);
        $this->courseRepoMock->getCourseList();
        $response = $this->courseController->getCourseList();

        $this->assertEquals(200, $response->getStatusCode());
    }

    public function test_can_delete_course()
    {
        $response = $this->delete(route('admin.courses.destroy', $this->course->id));
        $data = $response->getOriginalContent();

        $response->assertStatus(200);
        $this->assertEquals(trans('messages.json.success_delete'), $data['success']);
    }
}
